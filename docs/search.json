[
  {
    "objectID": "posts/dolar/index.html",
    "href": "posts/dolar/index.html",
    "title": "Consultado a cotação do Dólar",
    "section": "",
    "text": "Neste artigo, vou mostrar como desenvolver uma função em Python capaz de se conectar à API do Banco Central do Brasil (Olinda) para obter a cotação do dólar.\nAlém disso, demonstrarei como preencher automaticamente os dias sem cotação — como feriados e finais de semana — utilizando sempre a última cotação válida disponível. Esse processo garante uma série temporal completa e pronta para análise.\nTambém apresentarei um exemplo de como gerar um gráfico interativo utilizando Plotly, além de retornar um dicionário com os valores consolidados (opcional, útil para conferência ou processamento adicional).\n\nimport requests\nimport calendar\nfrom datetime import datetime, timedelta\nimport plotly.express as px\n\n\ndef get_cotacao_periodo(mmyyyy):\n    \"\"\"\n    Recebe uma string no formato 'MMYYYY'\n    Exemplo: '062010' → junho de 2010\n    Consulta a API do Banco Central e gera o gráfico da cotação diária.\n    \"\"\"\n\n    # Converter MMYYYY para um objeto datetime\n    first_date = datetime.strptime(mmyyyy, \"%m%Y\")\n\n    # Descobrir último dia do mês\n    last_day = calendar.monthrange(first_date.year, first_date.month)[1]\n\n    # Converter para formato MM-DD-YYYY exigido pela API\n    start_date = first_date.strftime(\"%m-%d-%Y\")\n    end_date = first_date.replace(day=last_day).strftime(\"%m-%d-%Y\")\n\n    # Montar URL correta da API\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        f\"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?\"\n        f\"@dataInicial='{start_date}'&@dataFinalCotacao='{end_date}'&$format=json\"\n    )\n\n    # Fazer requisição\n    response = requests.get(url).json()\n    valores_api = response[\"value\"]\n\n    # Guardar valores retornados pela API\n    cotacoes = {}\n    last_valid_value = None\n\n    for entrada in valores_api:\n        data = entrada[\"dataHoraCotacao\"][:10]  # pega YYYY-MM-DD\n        valor = entrada[\"cotacaoVenda\"]\n\n        cotacoes[data] = valor\n        last_valid_value = valor\n\n    # Preencher dias sem cotação (feriados e finais de semana)\n    datas_completas = {}\n    dia_atual = first_date\n    ultimo_dia = first_date.replace(day=last_day)\n\n    while dia_atual &lt;= ultimo_dia:\n        data_str = dia_atual.strftime(\"%Y-%m-%d\")\n\n        if data_str in cotacoes:\n            last_valid_value = cotacoes[data_str]\n\n        # usa última cotação válida (mesmo em dia sem info)\n        datas_completas[data_str] = last_valid_value\n\n        dia_atual += timedelta(days=1)\n\n    # Criar gráfico com Plotly\n    datas = list(datas_completas.keys())\n    valores = list(datas_completas.values())\n\n    fig = px.line(\n        x=datas,\n        y=valores,\n        title=f\"Cotação do Dólar — {first_date.strftime('%m/%Y')}\",\n        labels={\"x\": \"Data\", \"y\": \"Cotação (R$)\"}\n    )\n\n    fig.show()\n\n    # Retorna dicionário (opcional, só para checagem)\n    return datas_completas\n\n\n# Executar para junho de 2010 (seu mês)\nget_cotacao_periodo(\"062010\")\n\n                            \n                                            \n\n\n{'2010-06-01': 1.8255,\n '2010-06-02': 1.8362,\n '2010-06-03': 1.8362,\n '2010-06-04': 1.8401,\n '2010-06-05': 1.8401,\n '2010-06-06': 1.8401,\n '2010-06-07': 1.8634,\n '2010-06-08': 1.8658,\n '2010-06-09': 1.8423,\n '2010-06-10': 1.8185,\n '2010-06-11': 1.8125,\n '2010-06-12': 1.8125,\n '2010-06-13': 1.8125,\n '2010-06-14': 1.803,\n '2010-06-15': 1.7971,\n '2010-06-16': 1.7893,\n '2010-06-17': 1.7817,\n '2010-06-18': 1.7761,\n '2010-06-19': 1.7761,\n '2010-06-20': 1.7761,\n '2010-06-21': 1.7663,\n '2010-06-22': 1.768,\n '2010-06-23': 1.7908,\n '2010-06-24': 1.7907,\n '2010-06-25': 1.7781,\n '2010-06-26': 1.7781,\n '2010-06-27': 1.7781,\n '2010-06-28': 1.7826,\n '2010-06-29': 1.8076,\n '2010-06-30': 1.8015}"
  },
  {
    "objectID": "posts/regressao_linear/index.html",
    "href": "posts/regressao_linear/index.html",
    "title": "Regressão linear",
    "section": "",
    "text": "Este código realiza uma regressão linear simples usando dados armazenados em arquivos externos. Primeiro, ele carrega dois vetores numéricos, X e y, que representam o conjunto de entradas e saídas do modelo. Em seguida, constrói manualmente a matriz da regressão adicionando uma coluna de 1 para o termo constante e aplica a fórmula da solução analítica (método dos mínimos quadrados) para calcular os coeficientes da reta, resultando no intercepto a e na inclinação b. Depois transforma os dados em um DataFrame do pandas para facilitar a visualização e cria um gráfico com o plotnine, exibindo tanto os pontos originais quanto a linha de regressão calculada. O gráfico é então salvo como imagem e posteriormente carregado para ser exibido dentro do post do Quarto, permitindo visualizar o resultado da regressão diretamente dentro do blog.\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot, aes, geom_point, geom_abline, theme, element_text\n)\nfrom IPython.display import Image\n\n# 1. Ler os dados X e y\nX = np.loadtxt(\"X.txt\")\ny = np.loadtxt(\"y.txt\")\n\n# 2. Construir matriz para regressão\nX_matrix = np.column_stack((np.ones(len(X)), X))\nbeta = np.linalg.inv(X_matrix.T @ X_matrix) @ (X_matrix.T @ y)\n\na = beta[0]\nb = beta[1]\n\nprint(\"Coeficientes:\")\nprint(\"a (intercepto):\", a)\nprint(\"b (inclinação):\", b)\n\n# 3. DataFrame\ndf = pd.DataFrame({\"x\": X, \"y\": y})\n\n# 4. Gráfico\nplot = (\n    ggplot(df, aes(\"x\", \"y\"))\n    + geom_point()\n    + geom_abline(intercept=a, slope=b)\n    + theme(axis_title=element_text(size=12))\n)\n\n# 5. Salvar corretamente (plotnine)\nplot.save(\"grafico.png\")\n\n# 6. Exibir dentro do post do Quarto\nImage(\"grafico.png\")\n\nCoeficientes:\na (intercepto): 373.93446839132355\nb (inclinação): 991.6278332981952\n\n\n/home/codespace/.python/current/lib/python3.12/site-packages/plotnine/ggplot.py:623: PlotnineWarning: Saving 7.0 x 5.0 in image.\n/home/codespace/.python/current/lib/python3.12/site-packages/plotnine/ggplot.py:624: PlotnineWarning: Filename: grafico.png"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Scooby-doo",
    "section": "",
    "text": "Este blog foi desenvolvido para apresentar os trabalhos individuais realizados no curso de Engenharia de Computação, especificamente na disciplina Aprendendo Algoritmo."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scooby-Doo",
    "section": "",
    "text": "Regressão linear\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nSamuel Silva\n\n\n\n\n\n\n\n\n\n\n\n\nConsultado a cotação do Dólar\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nSamuel Silva\n\n\n\n\n\n\n\n\n\n\n\n\nMonitoramento de frota de ônibus\n\n\n\n\n\n\n\n\nNov 20, 2025\n\n\nSamuel Silva\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/monitoramento/index.html",
    "href": "posts/monitoramento/index.html",
    "title": "Monitoramento de frota de ônibus",
    "section": "",
    "text": "Este código utiliza a API Olho Vivo da SPTrans para buscar e exibir no mapa, em tempo real, a localização das paradas e dos ônibus de uma linha específica. Primeiro, o script carrega o token de autenticação armazenado no arquivo .env e realiza o login na API. Em seguida, consulta todas as paradas relacionadas ao número da linha informado e utiliza a primeira parada retornada para centralizar o mapa. Com o mapa criado pelo Folium, o código adiciona marcadores azuis representando cada parada, incluindo o nome mostrado ao clicar. Depois faz uma nova requisição para obter a posição atual dos veículos daquela linha e insere marcadores vermelhos para cada ônibus encontrado, exibindo seu prefixo. No final, o objeto m contém o mapa interativo completo, que aparece diretamente no post do Quarto, sem necessidade de salvar imagem ou arquivo externo.\n\nimport os\nimport requests\nfrom dotenv import load_dotenv\nimport folium\n\n# Carregar token do .env\nload_dotenv(\".env\")\nTOKEN = os.getenv(\"SPTRANS_TOKEN\")\nCODIGO_LINHA = 2506\nBASE_URL = \"http://api.olhovivo.sptrans.com.br/v2.1\"\n\n# AUTENTICAÇÃO\ns = requests.Session()\ns.post(f\"{BASE_URL}/Login/Autenticar?token={TOKEN}\")\n\n# BUSCAR PARADAS\nres_paradas = s.get(\n    f\"{BASE_URL}/Parada/BuscarParadasPorLinha?codigoLinha={CODIGO_LINHA}\"\n)\nparadas = res_paradas.json()\n\n# Criar mapa centralizado na primeira parada\nlat = paradas[0][\"py\"]\nlong = paradas[0][\"px\"]\n\nm = folium.Map(location=[lat, long], zoom_start=14)\n\n# PINS DAS PARADAS (AZUL)\nfor p in paradas:\n    folium.Marker(\n        location=[p[\"py\"], p[\"px\"]],\n        popup=p[\"np\"],\n        icon=folium.Icon(color=\"blue\")\n    ).add_to(m)\n\n# POSIÇÃO DOS VEÍCULOS (TEMPO REAL)\npos = s.get(f\"{BASE_URL}/Posicao/Linha?codigoLinha={CODIGO_LINHA}\").json()\nveiculos = pos[\"vs\"]\n\n# PINS DOS ÔNIBUS (VERMELHO)\nfor v in veiculos:\n    folium.Marker(\n        location=[v[\"py\"], v[\"px\"]],\n        popup=f\"Prefixo: {v['p']}\",\n        icon=folium.Icon(color=\"red\")\n    ).add_to(m)\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  }
]